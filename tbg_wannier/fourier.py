import numpy as np
from .lattice import MoireLattice


def build_wannier_Hk(eigvals: np.ndarray, U: np.ndarray) -> np.ndarray:
    """
    Build Wannier-gauge Hamiltonian H(k) from eigenvalues and U(k).

    Parameters
    ----------
    eigvals : (Nk, Nb)
        Band energies ε_n(k) at each k.
    U : (Nk, Nb, N_wann)
        Gauge matrix U(k) mapping bands -> Wannier functions:
            |w_n(k)> = sum_m |psi_m(k)> U_{m n}(k)

    Returns
    -------
    Hk : (Nk, N_wann, N_wann)
        Wannier-gauge Hamiltonian on the k-mesh:
            H_k[ik] = U(ik)† diag(eigvals[ik]) U(ik)
    """
    eigvals = np.asarray(eigvals, float)
    U = np.asarray(U, complex)

    Nk, Nb = eigvals.shape
    Nk2, Nb2, Nw = U.shape
    if Nk2 != Nk or Nb2 != Nb:
        raise ValueError(
            f"Shape mismatch: eigvals ({Nk},{Nb}), U ({Nk2},{Nb2},{Nw})"
        )

    Hk = np.zeros((Nk, Nw, Nw), dtype=complex)
    for ik in range(Nk):
        Ek = eigvals[ik]        # (Nb,)
        Uk = U[ik]              # (Nb, Nw)
        # U† diag(E) U
        Hk[ik] = Uk.conj().T @ np.diag(Ek) @ Uk

    return Hk

def _build_wannier_HR(
    Hk: np.ndarray,
    kpts: np.ndarray,
    Rvecs: np.ndarray,
) -> np.ndarray:
    """
    Build real-space hopping matrices H(R) from eigvals, U, and k-points.

    Parameters
    ----------
    eigvals : (Nk, Nb)
    U : (Nk, Nb, N_wann)
    kpts : (Nk, d)
        k-vectors (same ordering as eigvals and U).
        Can be in any coordinate system, as long as k·R is consistent with Rvecs.
    Rvecs : (NR, d)
        Real-space lattice vectors R over which to compute H(R).

    Returns
    -------
    HR : (NR, N_wann, N_wann)
        Real-space hoppings:
          HR[iR]_{mn} = sum_k exp(-i k·R_iR) H_k[ik]_{mn}
        with H_k built from eigvals and U.
        If NR == Nk, this matches your “shape Nk, N_wann, N_wann” statement.
    """
    kpts = np.asarray(kpts, float)
    Rvecs = np.asarray(Rvecs, float)

    Nk, Nw, _ = Hk.shape
    NR = Rvecs.shape[0]

    if kpts.shape[0] != Nk:
        raise ValueError("kpts must have first dimension Nk matching eigvals/U.")

    # phase[iR, ik] = exp(-i k(ik) · R(iR))
    # works for d=2 or d=3 as long as k and R are consistent
    phase = np.exp(-1j * 2*np.pi * (Rvecs @ kpts.T))  # (NR, Nk)

    # HR[iR] = sum_k phase[iR, k] * Hk[k]
    HR = np.tensordot(phase, Hk, axes=(1, 0)) / Nk  # (NR, Nw, Nw)

    return HR


def hk_to_hr_fft2(
    lat,
    Hk: np.ndarray,
    k_frac: np.ndarray,
) -> tuple[np.ndarray, dict]:
    """
    Compute real-space hoppings H(R) from H(k) using a 2D FFT on the moire mesh.

    Parameters
    ----------
    lat : MoireLattice-like
        Must provide real-space moire vectors:
          - lat.a1m : (2,) or (3,) Cartesian
          - lat.a2m : (2,) or (3,) Cartesian
        (Only the first two components are used if 3D.)
    Hk : (Nk, Nw, Nw) complex
        Wannier-gauge Hamiltonian on the k mesh.
        (Typically Hk[ik] = U(k)† diag(eps(k)) U(k).)
    k_frac : (Nk, 2) float
        Fractional coordinates (c1,c2) on a uniform NkxNky mesh.
        Must form a regular grid: Nk = Nkx*Nky.

    Returns
    -------
    HR_flat : (Nk, Nw, Nw) complex
        Real-space hoppings on the dual real-space grid (flattened in the same order
        as R grids returned in `meta`).
    meta : dict with:
        - "HR_grid": (Nkx, Nky, Nw, Nw) complex
        - "R_mn_grid": (Nkx, Nky, 2) int, integer lattice indices (m,n)
        - "R_cart_grid": (Nkx, Nky, d) float, Cartesian R vectors
        - "kx_vals": unique sorted k1 fractional values (length Nkx)
        - "ky_vals": unique sorted k2 fractional values (length Nky)

    Notes
    -----
    Convention implemented:
        HR[m,n] = (1/Nk) * sum_{i,j} Hk[i,j] * exp(-i 2π (i*m/Nkx + j*n/Nky))
    which matches exp(-i k·R) when k = (i/Nkx)b1 + (j/Nky)b2 and R = m a1 + n a2.
    """
    Hk = np.asarray(Hk, complex)
    k_frac = np.asarray(k_frac, float)
    N_k = lat.N_k
    Nk, Nw, Nw2 = Hk.shape
    if Nw != Nw2:
        raise ValueError("Hk must have shape (Nk, Nw, Nw).")
    # infer mesh dims from unique fractional coords
    kx_vals = np.unique(k_frac[:, 0])
    ky_vals = np.unique(k_frac[:, 1])
    Nkx, Nky = len(kx_vals), len(ky_vals)
    if Nkx * Nky != Nk:
        raise ValueError("k_frac does not form a regular Nkx*Nky mesh.")

    # map flat -> grid indices
    Hk_grid = np.zeros((Nkx, Nky, Nw, Nw), dtype=complex)
    for k_idx, k_val in enumerate(k_frac):
        # Recover i, j indices from linear enumeration of N_k x N_k mesh
        # Assuming k_mesh was generated by nested loops: for i... for j...
        i_k = k_idx // N_k
        j_k = k_idx % N_k
        Hk_grid[i_k, j_k, :, :] = Hk[k_idx]

    # 2D FFT over k-grid indices (axes 0,1). Normalize by Nk.
    HR_grid = np.fft.ifft2(Hk_grid, axes=(0, 1)) 

    # Build integer (m,n) grid corresponding to FFT output indices
    m = np.arange(-Nkx//2, Nkx//2)
    n = np.arange(-Nky//2, Nky//2)
    # m = np.arange(0, Nkx)
    # n = np.arange(0, Nky)
    m_grid, n_grid = np.meshgrid(m, n, indexing="ij")  # (Nkx,Nky)
    # print(m_grid)
    # print(n_grid)
    HR_grid = np.fft.fftshift(HR_grid, axes=(0, 1))
    # Cartesian R vectors from lattice moire vectors
    a1 = np.asarray(lat.a1, float).ravel()
    a2 = np.asarray(lat.a2, float).ravel()

    R_cart_grid = (m_grid[..., None] * a1[None, None, :] +
                   n_grid[..., None] * a2[None, None, :])  # (Nkx,Nky,d)


    return HR_grid, R_cart_grid

def compute_real_space_wannier(lat: MoireLattice, w_coeffs: np.ndarray, n_idx: int, alpha_idx: int, layer: int) -> tuple[np.ndarray, np.ndarray]:
    """
    Computes the real space Wannier function using FFT.
    
    Parameters:
    - lat: The k-Q lattice, contaning attributes like N_L, N_k, a1, a2, b1, b2, q2, Lmn, siteN.
    - w_coeffs: The coefficients matrix (e.g., from wannier_Ea or k_basis)
                Shape expected: (N_k * N_k, dim)
    - n_idx: Wannier function index.
    - alpha_idx: Sublattice index (1 or 2).
    - layer: Layer index (+1 for Top/Layer 1, -1 for Bottom/Layer 2).
    - k_mesh: The list of k-points, shape (N_k * N_k, 2).
    
    Returns:
    - W_real: 2D complex array of the Wannier function in real space, shape (N_L*N_k, N_L*N_k).
    - R_cart_grid: The real space coordinates for plotting, shape (N_L*N_k, N_L*N_k, 2).
    """
    
    # 1. Determine Grid Dimensions
    # L contains indices ranging from -N to N. 
    # We need to map L[i] + k_fraction to a single 2D array index.
    N_L = lat.N_L
    N_k = lat.N_k
    k_mesh = lat.k_cart
    Nk = k_mesh.shape[0]
    omega_0 = 8*np.pi**2/(3*np.sqrt(3)) # Moire unit cell area
    # The total grid size for FFT
    # Each unit cell of reciprocal lattice is subdivided by N_k points
    Grid_Size = N_L * N_k
    # Initialize the frequency domain grid (k-space)
    # We use complex128 for precision
    Vk_grid = np.zeros((Grid_Size, Grid_Size), dtype=complex)
    
    # 2. Populate the Grid
    # We iterate through the provided k_mesh and Lattice vectors to fill the 2D array
    
    # To allow integer indexing, we infer indices from the k_mesh generation logic:
    # k = (i/N_k) * b1 + (j/N_k) * b2
    
    for k_idx, k_val in enumerate(k_mesh):
        # Recover i, j indices from linear enumeration of N_k x N_k mesh
        # Assuming k_mesh was generated by nested loops: for i... for j...
        i_k = k_idx // N_k
        j_k = k_idx % N_k
        
        for i_L in range(lat.siteN):
            # Get Lattice integers (n1, n2)
            n1, n2 = lat.Lmn[i_L, 0], lat.Lmn[i_L, 1]
            
            # Get the specific coefficient v_{Q, beta, alpha}
            # Note: w_coeffs shape is likely (N_k^2, Total_Dim)
            if layer == 1: # Layer 1
                # v index based on prompt: 2*i + beta - 1
                coeff_idx = 2 * i_L + (alpha_idx - 1)
                val = w_coeffs[k_idx, coeff_idx, n_idx]
                
                # Momentum p = k - Q = k - (G + q2) = (k - G) - q2
                # We grid (k-G). G = n1*b1 + n2*b2.
                # Grid Index corresponds to vector components.
                # Component of b1: i_k/N_k - n1. 
                # We map this to positive integer indices for array storage.
                
                # Calculate integer grid position (centered)
                idx_1 = (i_k - n1 * N_k) % Grid_Size
                idx_2 = (j_k - n2 * N_k) % Grid_Size
                
            elif layer == -1: # Layer 2
                # v index based on prompt: 2*(i+siteN) + beta - 1
                coeff_idx = 2 * (i_L + lat.siteN) + (alpha_idx - 1)
                val = w_coeffs[k_idx, coeff_idx, n_idx]
                
                # Momentum p = k + Q = k + (G + q2) = (k + G) + q2
                # We grid (k+G)
                idx_1 = (i_k + n1 * N_k) % Grid_Size
                idx_2 = (j_k + n2 * N_k) % Grid_Size
            
            # Assign to grid
            Vk_grid[idx_1, idx_2] = val

    # 3. Perform FFT
    # We want sum_p exp(i p.r) v_p. This is an Inverse FFT operation.
    # (FFT definition varies by normalization and sign, standard numpy ifft includes 1/N)
    W_real = np.fft.ifft2(Vk_grid, norm="forward")/Nk  # Scaling factor to match normalization
    
    # Shift zero frequency to center for better visualization
    W_real = np.fft.fftshift(W_real)
    
    # 4. Coordinate Transformation and Phase Correction
    # The FFT assumes a standard orthogonal grid. We must generate the real space
    # coordinates corresponding to the reciprocal vectors b1m, b2m.
    
    # Real space lattice vectors (a1, a2) such that a_i . b_j = 2pi delta_ij
    # Given b1m, b2m, we can compute a1m, a2m numerically or analytically.
    # Here is a numerical trick to get the dual basis:
    # B = np.array([b1m, b2m])
    # A = 2 * np.pi * np.linalg.inv(B).T
    
    # Generate grid indices centered at 0
    x_range = np.arange(-Grid_Size//2, Grid_Size//2)
    y_range = np.arange(-Grid_Size//2, Grid_Size//2)

    X_idx, Y_idx = np.meshgrid(x_range, y_range, indexing='ij')
    
    # Map indices to real space coordinates (r = n_x * a1/N_L + n_y * a2/N_L)
    # The division by Grid_Size is because the recip grid step was dK = b/GridSize
    R_x = (X_idx * lat.a1[0] + Y_idx * lat.a2[0])/N_L
    R_y = (X_idx * lat.a1[1] + Y_idx * lat.a2[1])/N_L
    
    # 5. Apply the shift phase factor q2
    # For Layer 1: term was (k - G) - q2 -> We FFT'd (k-G), so multiply by exp(-i q2.r)
    # For Layer 2: term was (k + G) + q2 -> We FFT'd (k+G), so multiply by exp(+i q2.r)
    if layer == 1:
        phase = -1j * (R_x * lat.q2[0] + R_y * lat.q2[1])
    else:
        phase = 1j * (R_x * lat.q2[0] + R_y * lat.q2[1])
        
    W_real = W_real * np.exp(phase) / np.sqrt(omega_0)
    R_cart_grid = np.stack((R_x, R_y), axis=-1)
    # print(R_cart_grid.shape)
    return W_real, R_cart_grid